{"version":3,"sources":["../../src/controllers/AuthController.js"],"names":["authUser","req","res","username","body","cbGetUser","err","userData","status","send","errors","cbSendToken","token","_doc","password","created_at","update_at","__v","user","dataForLocalStorage","cbCheckPassword","isPasswordValid","jwt","sign","id","_id","keys","SECRET","expiresIn","bcrypt","compare","Users","findOne","verifyToken","next","bearerHeader","headers","undefined","bearerToken","split","cbDecodeToken","decoded","verify","message"],"mappings":"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","file":"AuthController.js","sourcesContent":["import Users from './../schemas/Users'\nimport bcrypt from 'bcrypt'\nimport jwt from 'jsonwebtoken'\nimport keys from './../keys'\n\n//authenticate user\nexport const authUser =(req, res)=> {\n    const username = {username : req.body.username}\n\n    const cbGetUser =(err, userData)=> {\n        if(err){\n         res.status(404).send({errors: err})\n        }else if(userData === null){//check if no user match the credentials\n         res.status(401).send({errors: \"no record found in database\"})\n        }else{\n            \n             if(!userData.status){//check if status is active\n                 res.status(401).send({errors: \"your account is registered, but we still need approval of the admin, please contact your system administrator\"})\n             }else{\n                \n                 const cbSendToken =(err, token)=> {//send token\n                    //destructure userData, exclude some fields\n                    const { password, created_at, update_at, __v, ...user} = userData._doc\n                    \n                    const dataForLocalStorage = {\n                        token: token,\n                        user: user\n                    }\n                    res.send(dataForLocalStorage)\n                }//cbSendToken\n\n                const cbCheckPassword =(err, isPasswordValid) => {// check if password valid and send token\n                    !isPasswordValid ? res.status(401).send({errors : \"invalid password\"}) \n                    :jwt.sign( {id : userData._id} , keys.SECRET, { expiresIn: '30s' }, cbSendToken)\n                }\n                \n                //check if password matches\n                bcrypt.compare(req.body.password, userData.password, cbCheckPassword)\n             }\n        }//else\n        \n    }//cbGetUser\n\n    //findOne by username\n    Users.findOne(username, cbGetUser)//findOne\n}//@end\n\nexport const verifyToken = (req, res, next) =>  {\n    const bearerHeader = req.headers['Authorization']\n\n    if(bearerHeader !== undefined){\n        const bearerToken = bearerHeader.split(' ')//split the Bearer and token\n        const token = bearerToken[1]// get the token on (Bearer token12eiuasd8)\n\n        const cbDecodeToken = (err, decoded) => {\n            // if token is doesn't have error and its not undefined\n            !err || decoded !== undefined ?  next() : res.status(401).send({errors: err})\n        }\n\n        jwt.verify(token, keys.SECRET, cbDecodeToken)\n\n    }else{\n        res.status(401).send({message: \"Not Authorized!\"})\n    }\n}//@end\n\n \n"]}